---
apply: always
---

---
apply: always
---

# REVIEW PROJECT RULES (SDET — JavaScript/TypeScript + Playwright + VS Code + npm)

These rules guide AI assistance for a Senior Software Developer in Test working primarily on:
- UI end-to-end tests with Playwright
- Lightweight scripts for data migration/maintenance

## 1) Ground truth & scope
- Do not invent files, selectors, APIs, test data, environments, or UI structure.
- Do not claim you ran tests, opened a browser, inspected the DOM, or verified results unless logs/artifacts are provided.
- If context is missing, state what is unknown and what must be verified (no guessing).

## 2) Output discipline (keep it clean)
- Keep output minimal and relevant; avoid extras.
- Prefer the smallest correct change (minimal diff) over refactors.
- Do not add defensive checks, redundant fallbacks, retries, or waits unless they address a concrete failure mode visible in code or described by the user.

## 3) Engineering principles (apply only when helpful)
- DRY: remove duplication only when it improves maintainability and does not hide intent.
- KISS: prefer simple, explicit code paths over abstraction.
- SOLID: apply where it reduces coupling and improves test clarity (avoid “frameworks within frameworks”).

## 4) Playwright testing rules (UI E2E)
### Locators & assertions
- Prefer Locator APIs and web-first assertions: `expect(locator)...` (auto-wait).
- Prefer stable selectors:
  - `getByRole` / accessible queries where appropriate
  - `data-testid` for explicit stability
  - avoid brittle CSS/XPath unless unavoidable and justified

### Waiting & timing
- Avoid fixed sleeps (`waitForTimeout`) and broad “wait for load” patterns.
- Wait only for a specific condition tied to the behavior under test:
  - UI state (`toBeVisible`, `toHaveText`, `toHaveCount`, etc.)
  - navigation/URL (`toHaveURL`)
  - specific network responses when necessary (`waitForResponse`)
- Do not introduce redundant waits “just in case.”

### Test isolation & determinism
- Tests must be parallel-safe and order-independent.
- No shared mutable state across tests.
- Setup/teardown must be explicit and deterministic.
- Prefer unique test data per test when data collisions are possible.

### Structure
- Use Arrange → Act → Assert (AAA).
- Prefer small focused tests; use long flows only when scenario requires it.
- Page Objects are optional:
  - Use them when they reduce duplication
  - Keep them thin (locators + actions)
  - Avoid deep inheritance or “god objects”

## 5) Flakiness control (root-cause first)
- Treat retries as a last resort; fix root causes (selectors, races, shared state, timing assumptions).
- Add traces/screenshots/video only when they improve diagnosis; don’t add heavy artifacts by default.
- When a test is flaky, identify the most likely cause and propose the minimal targeted fix.

## 6) TypeScript/JavaScript quality
- If TypeScript is used, assume strict-like discipline:
  - avoid `any`; prefer `unknown` + narrowing
  - avoid unsafe casts and non-null assertions unless a provable invariant exists
- Keep functions small and single-purpose.
- Prefer explicit naming and clear control flow over clever one-liners.

## 7) Data migration / maintenance scripts
- Scripts must be safe to run and easy to reason about:
  - explicit input/output
  - dry-run mode only when explicitly requested (don’t add by default)
  - clear logging (no secrets, no noisy debug spam)
- Avoid redundant checks and “fallback chains” that mask failures.
- Prefer failing fast with actionable errors over silently continuing.

## 8) Duplication policy (tests may repeat code)
- It is acceptable for tests to repeat code if it improves readability and local clarity.
- Only extract helpers when duplication:
  - creates maintenance risk (repeated complex steps), or
  - causes inconsistent behavior across tests, or
  - obscures the intent of the test
- Avoid creating generic helper layers that hide test meaning.

## 9) Security & safety
- Never log secrets, credentials, tokens, or PII.
- Use environment variables for sensitive configuration.
- Redact sensitive values from logs and reports.

## 10) Review / fix output format (default)
When reviewing or fixing code:
- Critical / Major / Minor (or “No issues found”)
- For each issue:
  - what/where
  - why it matters
  - concrete fix (minimal diff/snippet)
- End with a verification checklist (commands to run / what to observe)

## 11) Fixing IDE warnings/errors
- Fix root causes; do not silence issues with `eslint-disable`, `@ts-ignore`, `@ts-expect-error`, or casting to `any`.
- If a safe fix requires behavior change, state it explicitly and keep it minimal.